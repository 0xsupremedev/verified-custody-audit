"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.signFusionQuote = void 0;
const Helpers_1 = require("../../../modules/utils/Helpers.js");
const getPaymentToken_1 = require("./getPaymentToken.js");
const signOnChainQuote_1 = require("./signOnChainQuote.js");
const signPermitQuote_1 = require("./signPermitQuote.js");
const signFusionQuote = async (client, parameters) => {
    const paymentTokenInfo = await (0, getPaymentToken_1.getPaymentToken)(client, parameters.fusionQuote.trigger);
    let permitEnabled = false;
    if (paymentTokenInfo.paymentToken) {
        permitEnabled = paymentTokenInfo.paymentToken.permitEnabled || false;
    }
    else if (paymentTokenInfo.isArbitraryPaymentTokensSupported) {
        const modularSmartAccount = client.account.deploymentOn(parameters.fusionQuote.trigger.chainId, true);
        permitEnabled = await (0, Helpers_1.isPermitSupported)(modularSmartAccount.walletClient, parameters.fusionQuote.trigger.tokenAddress);
    }
    else {
        throw new Error(`Payment token (${parameters.fusionQuote.trigger.tokenAddress}) not supported for chain ${parameters.fusionQuote.trigger.chainId}`);
    }
    return permitEnabled
        ? (0, signPermitQuote_1.signPermitQuote)(client, parameters)
        : (0, signOnChainQuote_1.default)(client, parameters);
};
exports.signFusionQuote = signFusionQuote;
exports.default = exports.signFusionQuote;
//# sourceMappingURL=signFusionQuote.js.map