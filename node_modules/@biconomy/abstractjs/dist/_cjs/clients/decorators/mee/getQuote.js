"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.userOp = exports.getQuote = exports.USEROP_MIN_EXEC_WINDOW_DURATION = void 0;
const decorators_1 = require("../../../account/decorators/index.js");
const getMultichainContract_1 = require("../../../account/utils/getMultichainContract.js");
const resolveInstructions_1 = require("../../../account/utils/resolveInstructions.js");
const composabilityCalls_1 = require("../../../modules/utils/composabilityCalls.js");
exports.USEROP_MIN_EXEC_WINDOW_DURATION = 180;
const getQuote = async (client, parameters) => {
    const { account: account_ = client.account, instructions, cleanUps, feeToken, path = "quote", eoa, lowerBoundTimestamp: lowerBoundTimestamp_ = Math.floor(Date.now() / 1000), upperBoundTimestamp: upperBoundTimestamp_ = lowerBoundTimestamp_ +
        exports.USEROP_MIN_EXEC_WINDOW_DURATION, delegate = false, authorization } = parameters;
    const resolvedInstructions = await (0, resolveInstructions_1.resolveInstructions)(instructions);
    const validPaymentAccount = account_.deploymentOn(feeToken.chainId);
    const validFeeToken = validPaymentAccount &&
        client.info.supportedGasTokens
            .map(({ chainId }) => +chainId)
            .includes(feeToken.chainId);
    const validUserOps = resolvedInstructions.every((userOp) => account_.deploymentOn(userOp.chainId) &&
        client.info.supportedChains
            .map(({ chainId }) => +chainId)
            .includes(userOp.chainId));
    if (!validFeeToken) {
        throw Error(`Fee token ${feeToken.address} is not supported on this chain: ${feeToken.chainId}`);
    }
    if (!validPaymentAccount) {
        throw Error(`Account is not deployed on necessary chain(s) ${feeToken.chainId}`);
    }
    if (!validUserOps) {
        throw Error(`User operation chain(s) not supported by the node: ${resolvedInstructions
            .map((x) => x.chainId)
            .join(", ")}`);
    }
    const preparedUserOps = await prepareUserOps(account_, resolvedInstructions);
    if (cleanUps && cleanUps.length > 0) {
        const userOpsNonceInfo = preparedUserOps.map(([, { nonceKey, nonce }]) => ({ nonce, nonceKey }));
        const cleanUpUserOps = await prepareCleanUpUserOps(account_, userOpsNonceInfo, cleanUps);
        preparedUserOps.push(...cleanUpUserOps);
    }
    const hasProcessedInitData = [feeToken.chainId.toString()];
    const [nonce, isAccountDeployed, initCode] = await Promise.all([
        validPaymentAccount.getNonce(),
        validPaymentAccount.isDeployed(),
        validPaymentAccount.getInitCode()
    ]);
    const initData = isAccountDeployed
        ? undefined
        : delegate
            ? {
                eip7702Auth: await validPaymentAccount.toDelegation({ authorization })
            }
            : { initCode };
    const paymentInfo = {
        sender: validPaymentAccount.address,
        token: feeToken.address,
        nonce: nonce.toString(),
        chainId: feeToken.chainId.toString(),
        ...(eoa ? { eoa } : {}),
        ...initData
    };
    const userOps = await Promise.all(preparedUserOps.map(async ([callData, { nonce }, isAccountDeployed, initCode, sender, callGasLimit, chainId, isCleanUpUserOp, nexusAccount]) => {
        let initDataOrUndefined = undefined;
        const shouldContainInitData = !hasProcessedInitData.includes(chainId) && !isAccountDeployed;
        if (shouldContainInitData) {
            hasProcessedInitData.push(chainId);
            initDataOrUndefined = delegate
                ? {
                    eip7702Auth: await nexusAccount.toDelegation({ authorization })
                }
                : { initCode };
        }
        return {
            lowerBoundTimestamp: lowerBoundTimestamp_,
            upperBoundTimestamp: upperBoundTimestamp_,
            sender,
            callData,
            callGasLimit,
            nonce: nonce.toString(),
            chainId,
            isCleanUpUserOp,
            ...initDataOrUndefined
        };
    }));
    const quoteRequest = { userOps, paymentInfo };
    return await client.request({ path, body: quoteRequest });
};
exports.getQuote = getQuote;
const prepareUserOps = async (account, instructions, isCleanUpUserOps = false) => {
    return await Promise.all(instructions.map((userOp) => {
        const deployment = account.deploymentOn(userOp.chainId, true);
        let callsPromise;
        if (userOp.isComposable) {
            callsPromise = deployment.encodeExecuteComposable(userOp.calls);
        }
        else {
            callsPromise =
                userOp.calls.length > 1
                    ? deployment.encodeExecuteBatch(userOp.calls)
                    : deployment.encodeExecute(userOp.calls[0]);
        }
        return Promise.all([
            callsPromise,
            deployment.getNonceWithKey(),
            deployment.isDeployed(),
            deployment.getInitCode(),
            deployment.address,
            userOp.calls
                .map((uo) => uo?.gasLimit ?? getMultichainContract_1.LARGE_DEFAULT_GAS_LIMIT)
                .reduce((curr, acc) => curr + acc, 0n)
                .toString(),
            userOp.chainId.toString(),
            isCleanUpUserOps,
            deployment
        ]);
    }));
};
const userOp = (userOpIndex) => {
    if (userOpIndex <= 0)
        throw new Error("UserOp index should be greater than zero");
    return userOpIndex - 1;
};
exports.userOp = userOp;
const prepareCleanUpUserOps = async (account, userOpsNonceInfo, cleanUps) => {
    const cleanUpInstructions = await Promise.all(cleanUps.map(async (cleanUp) => {
        let amount = cleanUp.amount ?? 0n;
        if (amount === 0n) {
            amount = (0, composabilityCalls_1.runtimeERC20BalanceOf)({
                targetAddress: account.addressOn(cleanUp.chainId, true),
                tokenAddress: cleanUp.tokenAddress,
                constraints: [(0, composabilityCalls_1.greaterThanOrEqualTo)(1n)]
            });
        }
        const [cleanUpTransferInstruction] = await (0, decorators_1.buildComposable)({ account: account, currentInstructions: [] }, {
            type: "transfer",
            data: {
                recipient: cleanUp.recipientAddress,
                tokenAddress: cleanUp.tokenAddress,
                amount,
                chainId: cleanUp.chainId
            }
        });
        const nonceDependencies = [];
        if (cleanUp.dependsOn && cleanUp.dependsOn.length > 0) {
            for (const userOpIndex of cleanUp.dependsOn) {
                const userOpNonceInfo = userOpsNonceInfo[userOpIndex];
                if (!userOpNonceInfo)
                    throw new Error("Invalid UserOp dependency, please check the dependsOn configuration");
                const { nonce, nonceKey } = userOpNonceInfo;
                const nonceOf = (0, composabilityCalls_1.runtimeNonceOf)({
                    smartAccountAddress: account.addressOn(cleanUp.chainId, true),
                    nonceKey: nonceKey,
                    constraints: [(0, composabilityCalls_1.greaterThanOrEqualTo)(nonce + 1n)]
                });
                nonceDependencies.push(nonceOf);
            }
        }
        else {
            const lastUserOp = userOpsNonceInfo[userOpsNonceInfo.length - 1];
            const { nonce, nonceKey } = lastUserOp;
            const nonceOf = (0, composabilityCalls_1.runtimeNonceOf)({
                smartAccountAddress: account.addressOn(cleanUp.chainId, true),
                nonceKey: nonceKey,
                constraints: [(0, composabilityCalls_1.greaterThanOrEqualTo)(nonce + 1n)]
            });
            nonceDependencies.push(nonceOf);
        }
        const nonceDependencyInputParams = nonceDependencies.flatMap((dep) => dep.inputParams);
        cleanUpTransferInstruction.calls = cleanUpTransferInstruction.calls.map((call) => {
            call.inputParams.push(...nonceDependencyInputParams);
            return call;
        });
        return cleanUpTransferInstruction;
    }));
    const cleanUpUserOps = await prepareUserOps(account, cleanUpInstructions, true);
    return cleanUpUserOps;
};
exports.default = exports.getQuote;
//# sourceMappingURL=getQuote.js.map