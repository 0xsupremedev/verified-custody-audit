"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildComposableUtil = exports.buildComposableCall = void 0;
const viem_1 = require("viem");
const composabilityCalls_1 = require("../../../modules/utils/composabilityCalls.js");
const runtimeAbiEncoding_1 = require("../../../modules/utils/runtimeAbiEncoding.js");
const buildComposableCall = async (baseParams, parameters, efficientMode) => {
    const { account } = baseParams;
    const { to, gasLimit, value, functionName, args, abi, chainId } = parameters;
    if (!functionName || !args) {
        throw new Error("Invalid params for composable call");
    }
    if (!abi) {
        throw new Error("Invalid ABI");
    }
    if (!(0, viem_1.isAddress)(to)) {
        throw new Error("Invalid target contract address");
    }
    const smartAccountAddress = account.addressOn(chainId, true);
    if (!(0, viem_1.isAddress)(smartAccountAddress)) {
        throw new Error("Invalid smart account address");
    }
    if (args.length <= 0) {
        throw new Error("Composable call is not required for a instruction which has zero args");
    }
    const functionContext = (0, runtimeAbiEncoding_1.getFunctionContextFromAbi)(functionName, abi);
    if (functionContext?.inputs?.length !== args?.length) {
        throw new Error(`Invalid arguments for the ${functionName} function`);
    }
    const composableParams = (0, composabilityCalls_1.prepareComposableParams)([...functionContext.inputs], args);
    const composableCalls = [];
    const composableCall = {
        to: to,
        value: value ?? BigInt(0),
        functionSig: functionContext.functionSig,
        inputParams: efficientMode
            ? compressInputParams(composableParams)
            : composableParams,
        outputParams: [],
        ...(gasLimit ? { gasLimit } : {})
    };
    composableCalls.push(composableCall);
    return composableCalls;
};
exports.buildComposableCall = buildComposableCall;
const buildComposableUtil = async (baseParams, parameters, efficientMode = true) => {
    const { currentInstructions = [] } = baseParams;
    const calls = await (0, exports.buildComposableCall)(baseParams, parameters, efficientMode);
    return [
        ...currentInstructions,
        {
            calls: calls,
            chainId: parameters.chainId,
            isComposable: true
        }
    ];
};
exports.buildComposableUtil = buildComposableUtil;
exports.default = exports.buildComposableUtil;
const compressInputParams = (inputParams) => {
    const compressedParams = [];
    let currentParam = {
        fetcherType: composabilityCalls_1.InputParamFetcherType.RAW_BYTES,
        constraints: [],
        paramData: ""
    };
    for (const param of inputParams) {
        if (param.fetcherType === composabilityCalls_1.InputParamFetcherType.STATIC_CALL ||
            param.constraints.length > 0) {
            if (currentParam.paramData.length > 0) {
                compressedParams.push(currentParam);
                currentParam = {
                    fetcherType: composabilityCalls_1.InputParamFetcherType.RAW_BYTES,
                    constraints: [],
                    paramData: ""
                };
            }
            compressedParams.push(param);
            continue;
        }
        currentParam.paramData = (0, viem_1.concatHex)([
            currentParam.paramData,
            param.paramData
        ]);
    }
    if (currentParam.paramData.length > 0) {
        compressedParams.push(currentParam);
    }
    return compressedParams;
};
//# sourceMappingURL=buildComposable.js.map