"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseTransactionStatus = exports.FINAL_STATUSES = void 0;
exports.FINAL_STATUSES = ["FAILED", "MINED_SUCCESS", "MINED_FAIL"];
const parseTransactionStatus = async (userOps) => {
    if (!userOps || userOps.length === 0) {
        return {
            status: "PENDING",
            isFinalised: false,
            message: ""
        };
    }
    const userOpsWithoutCleanup = userOps.filter((usop) => !usop.isCleanUpUserOp);
    const statusMap = {
        hasFailedOps: userOpsWithoutCleanup.some((userOp) => userOp.executionStatus === "FAILED"),
        hasMinedFailOps: userOpsWithoutCleanup.some((userOp) => userOp.executionStatus === "MINED_FAIL"),
        hasPendingOps: userOpsWithoutCleanup.some((userOp) => userOp.executionStatus === "PENDING"),
        hasMiningOps: userOpsWithoutCleanup.some((userOp) => userOp.executionStatus === "MINING"),
        allMinedSuccess: userOpsWithoutCleanup.every((userOp) => userOp.executionStatus === "MINED_SUCCESS"),
        allFinalised: userOpsWithoutCleanup.every((userOp) => userOp.executionStatus === "FAILED" ||
            userOp.executionStatus === "MINED_FAIL" ||
            userOp.executionStatus === "MINED_SUCCESS")
    };
    let status = "PENDING";
    let message = "";
    if (statusMap.hasFailedOps) {
        status = "FAILED";
        const failedUserOpIndex = userOpsWithoutCleanup.findIndex((userOp) => userOp.executionStatus === status);
        const failedUserOp = userOpsWithoutCleanup[failedUserOpIndex];
        message = `[${failedUserOpIndex}] ${failedUserOp?.executionError || "Transaction failed off-chain"}`;
    }
    else if (statusMap.hasMinedFailOps) {
        status = "MINED_FAIL";
        const minedFailUserOpIndex = userOpsWithoutCleanup.findIndex((userOp) => userOp.executionStatus === status);
        const minedFailUserOp = userOpsWithoutCleanup[minedFailUserOpIndex];
        message = `[${minedFailUserOpIndex}] ${minedFailUserOp?.executionError || "Transaction failed on-chain"}`;
    }
    else if (statusMap.hasMiningOps) {
        status = "MINING";
        const pendingUserOpIndex = userOpsWithoutCleanup.findIndex((userOp) => userOp.executionStatus === status);
        message = `[${pendingUserOpIndex}] Transaction is mining, waiting for blockchain confirmation`;
    }
    else if (statusMap.hasPendingOps) {
        status = "PENDING";
        const pendingUserOpIndex = userOpsWithoutCleanup.findIndex((userOp) => userOp.executionStatus === status);
        const pendingUserOp = userOpsWithoutCleanup[pendingUserOpIndex];
        message = `[${pendingUserOpIndex}] ${pendingUserOp?.executionError || "Transaction is pending, waiting for conditions to be met"}`;
    }
    else if (statusMap.allMinedSuccess) {
        status = "MINED_SUCCESS";
        const minedSuccessUserOpIndex = userOpsWithoutCleanup.findIndex((userOp) => userOp.executionStatus === status);
        message = `[${minedSuccessUserOpIndex}] Transaction executed successfully`;
    }
    const isFinalised = statusMap.allFinalised ||
        statusMap.hasFailedOps ||
        statusMap.hasMinedFailOps;
    return {
        status,
        isFinalised,
        message
    };
};
exports.parseTransactionStatus = parseTransactionStatus;
exports.default = exports.parseTransactionStatus;
//# sourceMappingURL=parseTransactionStatus.js.map