"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.toMultichainNexusAccount = toMultichainNexusAccount;
const toNexusAccount_1 = require("./toNexusAccount.js");
const build_1 = require("./decorators/build.js");
const buildBridgeInstructions_1 = require("./decorators/buildBridgeInstructions.js");
const getUnifiedERC20Balance_1 = require("./decorators/getUnifiedERC20Balance.js");
const isDelegated_1 = require("./decorators/isDelegated.js");
const queryBridge_1 = require("./decorators/queryBridge.js");
const unDelegate_1 = require("./decorators/unDelegate.js");
const waitForTransactionReceipts_1 = require("./decorators/waitForTransactionReceipts.js");
async function toMultichainNexusAccount(multiChainNexusParams) {
    const { chains, signer: unresolvedSigner, transports, ...accountParameters } = multiChainNexusParams;
    if (chains.length === 0) {
        throw new Error("No chains provided");
    }
    if (transports && transports.length !== chains.length) {
        throw new Error("The number of transports must match the number of chains provided");
    }
    const deployments = await Promise.all(chains.map((chain, i) => (0, toNexusAccount_1.toNexusAccount)({
        chain,
        signer: unresolvedSigner,
        transport: transports[i],
        ...accountParameters
    })));
    function deploymentOn(chainId, strictMode) {
        const deployment = deployments.find((dep) => dep.client.chain?.id === chainId);
        if (!deployment && strictMode) {
            throw new Error(`Deployment not found for chainId: ${chainId}`);
        }
        return deployment;
    }
    function addressOn(chainId, strictMode) {
        const deployment = deploymentOn(chainId, strictMode);
        return deployment?.address;
    }
    const baseAccount = {
        signer: deployments[0].signer,
        deployments,
        deploymentOn,
        addressOn
    };
    const getUnifiedERC20Balance = (mcToken) => (0, getUnifiedERC20Balance_1.getUnifiedERC20Balance)({ mcToken, account: baseAccount });
    const build = (params, currentInstructions) => (0, build_1.build)({ currentInstructions, account: baseAccount }, params);
    const buildComposable = (params, currentInstructions) => (0, build_1.buildComposable)({ currentInstructions, account: baseAccount }, params);
    const buildBridgeInstructions = (params) => (0, buildBridgeInstructions_1.buildBridgeInstructions)({ ...params, account: baseAccount });
    const queryBridge = (params) => (0, queryBridge_1.queryBridge)({ ...params, account: baseAccount });
    const isDelegated = (parameters) => (0, isDelegated_1.isDelegated)({ ...parameters, account: baseAccount });
    const unDelegate = (parameters) => (0, unDelegate_1.unDelegate)({ ...parameters, account: baseAccount });
    const waitForTransactionReceipts = (parameters) => (0, waitForTransactionReceipts_1.waitForTransactionReceipts)({ ...parameters, account: baseAccount });
    const toDelegation = async () => await deployments[0].toDelegation({ multiChain: true });
    return {
        ...baseAccount,
        getUnifiedERC20Balance,
        build,
        buildComposable,
        buildBridgeInstructions,
        queryBridge,
        isDelegated,
        unDelegate,
        waitForTransactionReceipts,
        toDelegation
    };
}
//# sourceMappingURL=toMultiChainNexusAccount.js.map