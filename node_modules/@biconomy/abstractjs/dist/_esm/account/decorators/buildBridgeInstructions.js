import { toAcrossPlugin } from "../utils/toAcrossPlugin.js";
import { queryBridge } from "./queryBridge.js";
/**
 * Makes sure that the user has enough funds on the selected chain before filling the
 * supertransaction. Bridges funds from other chains if needed.
 *
 * @param params - {@link MultichainBridgingParams} Configuration for the bridge operation
 * @param params.account - The smart account to execute the bridging
 * @param params.amount - The amount to bridge
 * @param params.toChain - The destination chain
 * @param params.unifiedBalance - Current token balances across chains
 * @param params.bridgingPlugins - Optional array of bridging plugins (defaults to Across)
 * @param params.feeData - Optional fee configuration
 * @param params.mode - The mode of the bridge operation, defaults to "DEBIT". In optimistic mode, the bridging instructions are returned without preexisting balance checks.
 *
 * @returns Promise resolving to {@link BridgingInstructions} containing all necessary operations
 *
 * @throws Error if insufficient balance is available for bridging
 * @throws Error if chain configuration is missing for any deployment
 *
 * @example
 * const bridgeInstructions = await buildBridgeInstructions({
 *   account: myMultichainAccount,
 *   amount: BigInt("1000000"), // 1 USDC
 *   toChain: optimism,
 *   unifiedBalance: myTokenBalance,
 *   bridgingPlugins: [acrossPlugin],
 *   feeData: {
 *     txFeeChainId: 1,
 *     txFeeAmount: BigInt("100000")
 *   }
 * });
 */
export const buildBridgeInstructions = async (params) => {
    const { account, amount: targetAmount, toChain, unifiedBalance, bridgingPlugins = [toAcrossPlugin()], feeData, mode = "DEBIT" } = params;
    const tokenMapping = {
        on: (chainId) => unifiedBalance.mcToken.deployments.get(chainId) || "0x",
        deployments: Array.from(unifiedBalance.mcToken.deployments.entries(), ([chainId, address]) => ({
            chainId,
            address
        }))
    };
    // Get current balance on destination chain
    const destinationBalance = unifiedBalance.breakdown.find((b) => b.chainId === toChain.id)?.balance ||
        0n;
    // If we have enough on destination, no bridging needed
    if (destinationBalance >= targetAmount) {
        return {
            instructions: [],
            meta: {
                bridgingInstructions: [],
                totalAvailableOnDestination: destinationBalance
            }
        };
    }
    // Calculate how much we need to bridge
    const amountToBridge = targetAmount - destinationBalance;
    // Get available balances from source chains
    const sourceBalances = unifiedBalance.breakdown
        .filter((balance) => balance.chainId !== toChain.id)
        .map((balance_) => {
        // If we are in optimistic mode, we need to retrieve instructions for the bridging action regardless of the balance
        const balancePerChain = mode === "DEBIT" ? balance_ : { ...balance_, balance: targetAmount };
        // If this is the fee payment chain, adjust available balance
        const isFeeChain = feeData && feeData.txFeeChainId === balancePerChain.chainId;
        const availableBalance = isFeeChain && "txFeeAmount" in feeData
            ? balancePerChain.balance > feeData.txFeeAmount
                ? balancePerChain.balance - feeData.txFeeAmount
                : 0n
            : balancePerChain.balance;
        return {
            chainId: balancePerChain.chainId,
            balance: availableBalance
        };
    })
        .filter((balance) => balance.balance > 0n);
    // Get chain configurations
    const chains = Object.fromEntries(account.deployments.map((deployment) => {
        const chain = deployment.client.chain;
        if (!chain) {
            throw new Error(`Client not configured with chain for deployment at ${deployment.address}`);
        }
        return [chain.id, chain];
    }));
    // Query all possible routes
    const bridgeQueries = sourceBalances.flatMap((source) => {
        const fromChain = chains[source.chainId];
        if (!fromChain)
            return [];
        return bridgingPlugins.map((plugin) => queryBridge({
            fromChain,
            toChain,
            plugin,
            amount: source.balance,
            account,
            tokenMapping
        }));
    });
    const bridgeResults = (await Promise.all(bridgeQueries))
        .filter((result) => result !== null)
        // Sort by received amount relative to sent amount
        .sort((a, b) => Number((b.receivedAtDestination * 10000n) / b.amount) -
        Number((a.receivedAtDestination * 10000n) / a.amount));
    // Build instructions by taking from best routes until we have enough
    const { bridgingInstructions, instructions, totalBridged, remainingNeeded } = bridgeResults.reduce((acc, result) => {
        if (acc.remainingNeeded <= 0n)
            return acc;
        const amountToTake = result.amount >= acc.remainingNeeded
            ? acc.remainingNeeded
            : result.amount;
        const receivedFromRoute = (result.receivedAtDestination * amountToTake) / result.amount;
        return {
            bridgingInstructions: [
                ...acc.bridgingInstructions,
                {
                    userOp: result.userOp,
                    receivedAtDestination: receivedFromRoute,
                    bridgingDurationExpectedMs: result.bridgingDurationExpectedMs
                }
            ],
            instructions: [...acc.instructions, result.userOp],
            totalBridged: acc.totalBridged + receivedFromRoute,
            remainingNeeded: acc.remainingNeeded - amountToTake
        };
    }, {
        bridgingInstructions: [],
        instructions: [],
        totalBridged: 0n,
        remainingNeeded: amountToBridge
    });
    // Check if we got enough
    if (remainingNeeded > 0n) {
        throw new Error(`Insufficient balance for bridging:
         Required: ${targetAmount.toString()}
         Available to bridge: ${totalBridged.toString()}
         Shortfall: ${remainingNeeded.toString()}`);
    }
    return {
        instructions,
        meta: {
            bridgingInstructions,
            totalAvailableOnDestination: destinationBalance + totalBridged
        }
    };
};
export default buildBridgeInstructions;
//# sourceMappingURL=buildBridgeInstructions.js.map