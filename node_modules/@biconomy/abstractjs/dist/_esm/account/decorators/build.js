import { buildApprove } from "./instructions/buildApprove.js";
import buildBatch, {} from "./instructions/buildBatch.js";
import buildComposableUtil, {} from "./instructions/buildComposable.js";
import { buildDefaultInstructions } from "./instructions/buildDefaultInstructions.js";
import { buildIntent } from "./instructions/buildIntent.js";
import { buildMultichainInstructions } from "./instructions/buildMultichainInstructions.js";
import buildRawComposable, {} from "./instructions/buildRawComposable.js";
import { buildTransfer } from "./instructions/buildTransfer.js";
import { buildTransferFrom } from "./instructions/buildTransferFrom.js";
import buildWithdrawal, {} from "./instructions/buildWithdrawal.js";
/**
 * Builds transaction instructions based on the provided action type and parameters
 *
 * @param baseParams - {@link BaseInstructionsParams} Base configuration for instructions
 * @param baseParams.account - The multichain smart account to check balances for
 * @param baseParams.currentInstructions - Optional array of existing instructions to append to
 * @param parameters - {@link BuildInstructionTypes} The build action configuration
 * @param parameters.type - The type of build action ("default" | "intent")
 * @param parameters.data - Action-specific parameters based on the type
 *
 * @returns Promise resolving to an array of {@link Instruction}
 *
 * @example
 * // Bridge tokens example
 * const bridgeInstructions = await build(
 *   { account: myMultichainAccount },
 *   {
 *     type: "intent",
 *     data: {
 *       amount: BigInt(1000000),
 *       mcToken: mcUSDC,
 *       toChain: optimism
 *     }
 *   }
 * );
 *
 * @example
 * // Default action example
 * const defaultInstructions = await build(
 *   { account: myMultichainAccount },
 *   {
 *     type: "default",
 *     data: {
 *       instructions: myExistingInstruction
 *     }
 *   }
 * );
 */
export const build = async (baseParams, parameters) => {
    const { type, data } = parameters;
    switch (type) {
        case "intent": {
            return buildIntent(baseParams, data);
        }
        case "default": {
            return buildDefaultInstructions(baseParams, data);
        }
        case "transferFrom": {
            return buildTransferFrom(baseParams, data);
        }
        case "transfer": {
            return buildTransfer(baseParams, data);
        }
        case "approve": {
            return buildApprove(baseParams, data);
        }
        case "withdrawal": {
            return buildWithdrawal(baseParams, data);
        }
        case "batch": {
            return buildBatch(baseParams, data);
        }
        case "multichain": {
            return buildMultichainInstructions(baseParams, data);
        }
        default: {
            throw new Error(`Unknown build action type: ${type}`);
        }
    }
};
// Exactly same as build decorator, but forces to use composable call.
export const buildComposable = async (baseParams, parameters) => {
    const { type, data, efficientMode } = parameters;
    switch (type) {
        case "default": {
            return buildComposableUtil(baseParams, data, efficientMode);
        }
        case "rawCalldata": {
            return buildRawComposable(baseParams, data);
        }
        case "transferFrom": {
            return buildTransferFrom(baseParams, data, true, efficientMode);
        }
        case "transfer": {
            return buildTransfer(baseParams, data, true, efficientMode);
        }
        case "approve": {
            return buildApprove(baseParams, data, true, efficientMode);
        }
        case "withdrawal": {
            return buildWithdrawal(baseParams, data, true, efficientMode);
        }
        case "batch": {
            return buildBatch(baseParams, data);
        }
        default: {
            throw new Error(`Unknown build action type: ${type}`);
        }
    }
};
export default build;
//# sourceMappingURL=build.js.map