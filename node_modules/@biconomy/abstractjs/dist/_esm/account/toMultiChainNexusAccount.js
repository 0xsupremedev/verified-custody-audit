import { toNexusAccount } from "./toNexusAccount.js";
import { buildComposable as buildComposableDecorator, build as buildDecorator } from "./decorators/build.js";
import { buildBridgeInstructions as buildBridgeInstructionsDecorator } from "./decorators/buildBridgeInstructions.js";
import { getUnifiedERC20Balance as getUnifiedERC20BalanceDecorator } from "./decorators/getUnifiedERC20Balance.js";
import { isDelegated as isDelegatedDecorator } from "./decorators/isDelegated.js";
import { queryBridge as queryBridgeDecorator } from "./decorators/queryBridge.js";
import { unDelegate as unDelegateDecorator } from "./decorators/unDelegate.js";
import { waitForTransactionReceipts as waitForTransactionReceiptsDecorator } from "./decorators/waitForTransactionReceipts.js";
/**
 * Creates a multichain Nexus account across specified chains
 *
 * @param parameters - {@link MultichainNexusParams} Configuration for multichain account creation
 * @param parameters.signer - The signer instance used for account creation
 * @param parameters.chains - Array of chains where the account will be deployed
 *
 * @returns Promise resolving to {@link MultichainSmartAccount} instance
 *
 * @throws Error if account creation fails on any chain
 *
 * @example
 * const account = await toMultichainNexusAccount({
 *   signer: mySigner,
 *   chains: [optimism, base],
 *   transports: [http(), http()]
 * });
 *
 * // Get deployment on specific chain
 * const optimismDeployment = account.deploymentOn(10);
 *
 * // Check token balance across chains
 * const balance = await account.getUnifiedERC20Balance(mcUSDC);
 *
 * // Build bridge transaction
 * const bridgeInstructions = await account.buildBridgeInstructions({
 *   amount: BigInt("1000000"), // 1 USDC
 *   mcToken: mcUSDC,
 *   toChain: base
 * });
 */
export async function toMultichainNexusAccount(multiChainNexusParams) {
    const { chains, signer: unresolvedSigner, transports, ...accountParameters } = multiChainNexusParams;
    if (chains.length === 0) {
        throw new Error("No chains provided");
    }
    if (transports && transports.length !== chains.length) {
        throw new Error("The number of transports must match the number of chains provided");
    }
    const deployments = await Promise.all(chains.map((chain, i) => toNexusAccount({
        chain,
        signer: unresolvedSigner,
        transport: transports[i],
        ...accountParameters
    })));
    function deploymentOn(chainId, strictMode) {
        const deployment = deployments.find((dep) => dep.client.chain?.id === chainId);
        if (!deployment && strictMode) {
            throw new Error(`Deployment not found for chainId: ${chainId}`);
        }
        return deployment;
    }
    function addressOn(chainId, strictMode) {
        const deployment = deploymentOn(chainId, strictMode);
        return deployment?.address;
    }
    const baseAccount = {
        signer: deployments[0].signer, // This signer is resolved
        deployments,
        deploymentOn,
        addressOn
    };
    const getUnifiedERC20Balance = (mcToken) => getUnifiedERC20BalanceDecorator({ mcToken, account: baseAccount });
    const build = (params, currentInstructions) => buildDecorator({ currentInstructions, account: baseAccount }, params);
    const buildComposable = (params, currentInstructions) => buildComposableDecorator({ currentInstructions, account: baseAccount }, params);
    const buildBridgeInstructions = (params) => buildBridgeInstructionsDecorator({ ...params, account: baseAccount });
    const queryBridge = (params) => queryBridgeDecorator({ ...params, account: baseAccount });
    const isDelegated = (parameters) => isDelegatedDecorator({ ...parameters, account: baseAccount });
    const unDelegate = (parameters) => unDelegateDecorator({ ...parameters, account: baseAccount });
    const waitForTransactionReceipts = (parameters) => waitForTransactionReceiptsDecorator({ ...parameters, account: baseAccount });
    // The specific deployment doesn't matter here because chainId = 0
    const toDelegation = async () => await deployments[0].toDelegation({ multiChain: true });
    return {
        ...baseAccount,
        getUnifiedERC20Balance,
        build,
        buildComposable,
        buildBridgeInstructions,
        queryBridge,
        isDelegated,
        unDelegate,
        waitForTransactionReceipts,
        toDelegation
    };
}
//# sourceMappingURL=toMultiChainNexusAccount.js.map