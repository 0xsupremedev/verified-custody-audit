import { buildComposable } from "../../../account/decorators/index.js";
import { LARGE_DEFAULT_GAS_LIMIT } from "../../../account/utils/getMultichainContract.js";
import { resolveInstructions } from "../../../account/utils/resolveInstructions.js";
import { greaterThanOrEqualTo, runtimeERC20BalanceOf, runtimeNonceOf } from "../../../modules/utils/composabilityCalls.js";
export const USEROP_MIN_EXEC_WINDOW_DURATION = 180;
/**
 * Requests a quote from the MEE service for executing a set of instructions.
 * This function handles the complexity of creating a supertransaction quote
 * that can span multiple chains.
 *
 * @param client - MEE client instance used to make the request
 * @param parameters - Parameters for the quote request
 * @returns Promise resolving to a committed supertransaction quote
 *
 * @example
 * ```typescript
 * const quote = await getQuote(meeClient, {
 *   instructions: [{
 *     calls: [{
 *       to: "0x742d35Cc6634C0532925a3b844Bc454e4438f44e",
 *       data: "0x...",
 *       value: 0n
 *     }],
 *     chainId: 1 // Ethereum Mainnet
 *   }],
 *   feeToken: {
 *     address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48", // USDC
 *     chainId: 1
 *   }
 * });
 * ```
 *
 * @throws Will throw an error if:
 * - The account is not deployed on required chains
 * - The fee token is not supported
 * - The chain(s) are not supported by the node
 */
export const getQuote = async (client, parameters) => {
    const { account: account_ = client.account, instructions, cleanUps, feeToken, path = "quote", eoa, lowerBoundTimestamp: lowerBoundTimestamp_ = Math.floor(Date.now() / 1000), upperBoundTimestamp: upperBoundTimestamp_ = lowerBoundTimestamp_ +
        USEROP_MIN_EXEC_WINDOW_DURATION, delegate = false, authorization } = parameters;
    const resolvedInstructions = await resolveInstructions(instructions);
    const validPaymentAccount = account_.deploymentOn(feeToken.chainId);
    const validFeeToken = validPaymentAccount &&
        client.info.supportedGasTokens
            .map(({ chainId }) => +chainId)
            .includes(feeToken.chainId);
    const validUserOps = resolvedInstructions.every((userOp) => account_.deploymentOn(userOp.chainId) &&
        client.info.supportedChains
            .map(({ chainId }) => +chainId)
            .includes(userOp.chainId));
    if (!validFeeToken) {
        throw Error(`Fee token ${feeToken.address} is not supported on this chain: ${feeToken.chainId}`);
    }
    if (!validPaymentAccount) {
        throw Error(`Account is not deployed on necessary chain(s) ${feeToken.chainId}`);
    }
    if (!validUserOps) {
        throw Error(`User operation chain(s) not supported by the node: ${resolvedInstructions
            .map((x) => x.chainId)
            .join(", ")}`);
    }
    const preparedUserOps = await prepareUserOps(account_, resolvedInstructions);
    // If cleanup is configured, the cleanup userops will be appended to the existing userops
    // Every cleanup is a separate user op and will be executed if certain conditions met
    if (cleanUps && cleanUps.length > 0) {
        const userOpsNonceInfo = preparedUserOps.map(([, { nonceKey, nonce }]) => ({ nonce, nonceKey }));
        const cleanUpUserOps = await prepareCleanUpUserOps(account_, userOpsNonceInfo, cleanUps);
        preparedUserOps.push(...cleanUpUserOps);
    }
    const hasProcessedInitData = [feeToken.chainId.toString()];
    const [nonce, isAccountDeployed, initCode] = await Promise.all([
        validPaymentAccount.getNonce(),
        validPaymentAccount.isDeployed(),
        validPaymentAccount.getInitCode()
    ]);
    // Do authorization only if required as it requires signing
    const initData = isAccountDeployed
        ? undefined
        : delegate
            ? {
                eip7702Auth: await validPaymentAccount.toDelegation({ authorization })
            }
            : { initCode };
    const paymentInfo = {
        sender: validPaymentAccount.address,
        token: feeToken.address,
        nonce: nonce.toString(),
        chainId: feeToken.chainId.toString(),
        ...(eoa ? { eoa } : {}),
        ...initData
    };
    const userOps = await Promise.all(preparedUserOps.map(async ([callData, { nonce }, isAccountDeployed, initCode, sender, callGasLimit, chainId, isCleanUpUserOp, nexusAccount]) => {
        let initDataOrUndefined = undefined;
        const shouldContainInitData = !hasProcessedInitData.includes(chainId) && !isAccountDeployed;
        if (shouldContainInitData) {
            hasProcessedInitData.push(chainId);
            initDataOrUndefined = delegate
                ? {
                    eip7702Auth: await nexusAccount.toDelegation({ authorization })
                }
                : { initCode };
        }
        return {
            lowerBoundTimestamp: lowerBoundTimestamp_,
            upperBoundTimestamp: upperBoundTimestamp_,
            sender,
            callData,
            callGasLimit,
            nonce: nonce.toString(),
            chainId,
            isCleanUpUserOp,
            ...initDataOrUndefined
        };
    }));
    const quoteRequest = { userOps, paymentInfo };
    return await client.request({ path, body: quoteRequest });
};
const prepareUserOps = async (account, instructions, isCleanUpUserOps = false) => {
    return await Promise.all(instructions.map((userOp) => {
        const deployment = account.deploymentOn(userOp.chainId, true);
        let callsPromise;
        if (userOp.isComposable) {
            callsPromise = deployment.encodeExecuteComposable(userOp.calls);
        }
        else {
            callsPromise =
                userOp.calls.length > 1
                    ? deployment.encodeExecuteBatch(userOp.calls)
                    : deployment.encodeExecute(userOp.calls[0]);
        }
        return Promise.all([
            callsPromise,
            deployment.getNonceWithKey(),
            deployment.isDeployed(),
            deployment.getInitCode(),
            deployment.address,
            userOp.calls
                .map((uo) => uo?.gasLimit ?? LARGE_DEFAULT_GAS_LIMIT)
                .reduce((curr, acc) => curr + acc, 0n)
                .toString(),
            userOp.chainId.toString(),
            isCleanUpUserOps,
            deployment
        ]);
    }));
};
export const userOp = (userOpIndex) => {
    if (userOpIndex <= 0)
        throw new Error("UserOp index should be greater than zero");
    // During the userop building, the payment user ops is not available. But the slot 1 is always reserved for payment userop
    // as standard practise. Hence, the userOp will indirectly implies this by -1 which yields the first userop defined by devs
    return userOpIndex - 1;
};
const prepareCleanUpUserOps = async (account, userOpsNonceInfo, cleanUps) => {
    const cleanUpInstructions = await Promise.all(cleanUps.map(async (cleanUp) => {
        let amount = cleanUp.amount ?? 0n;
        // If there is no amount specified ? Runtime amount will be cleaned up by default
        if (amount === 0n) {
            amount = runtimeERC20BalanceOf({
                targetAddress: account.addressOn(cleanUp.chainId, true),
                tokenAddress: cleanUp.tokenAddress,
                constraints: [greaterThanOrEqualTo(1n)] // Cleanup will only happen if there is atleast 1 wei
            });
        }
        const [cleanUpTransferInstruction] = await buildComposable({ account: account, currentInstructions: [] }, {
            type: "transfer",
            data: {
                recipient: cleanUp.recipientAddress,
                tokenAddress: cleanUp.tokenAddress,
                amount,
                chainId: cleanUp.chainId
            }
        });
        const nonceDependencies = [];
        if (cleanUp.dependsOn && cleanUp.dependsOn.length > 0) {
            for (const userOpIndex of cleanUp.dependsOn) {
                const userOpNonceInfo = userOpsNonceInfo[userOpIndex];
                if (!userOpNonceInfo)
                    throw new Error("Invalid UserOp dependency, please check the dependsOn configuration");
                const { nonce, nonceKey } = userOpNonceInfo;
                const nonceOf = runtimeNonceOf({
                    smartAccountAddress: account.addressOn(cleanUp.chainId, true),
                    nonceKey: nonceKey,
                    constraints: [greaterThanOrEqualTo(nonce + 1n)]
                });
                nonceDependencies.push(nonceOf);
            }
        }
        else {
            const lastUserOp = userOpsNonceInfo[userOpsNonceInfo.length - 1];
            const { nonce, nonceKey } = lastUserOp;
            const nonceOf = runtimeNonceOf({
                smartAccountAddress: account.addressOn(cleanUp.chainId, true),
                nonceKey: nonceKey,
                constraints: [greaterThanOrEqualTo(nonce + 1n)]
            });
            nonceDependencies.push(nonceOf);
        }
        const nonceDependencyInputParams = nonceDependencies.flatMap((dep) => dep.inputParams);
        cleanUpTransferInstruction.calls = cleanUpTransferInstruction.calls.map((call) => {
            call.inputParams.push(...nonceDependencyInputParams);
            return call;
        });
        return cleanUpTransferInstruction;
    }));
    const cleanUpUserOps = await prepareUserOps(account, cleanUpInstructions, true);
    return cleanUpUserOps;
};
export default getQuote;
//# sourceMappingURL=getQuote.js.map