import { type Address } from "abitype";
import type { BridgingPlugin, BridgingPluginResult, BridgingUserOpParams } from "../decorators/buildBridgeInstructions";
/**
 * Response type for Across bridge relay fee information
 * @interface AcrossRelayFeeResponse
 */
export interface AcrossRelayFeeResponse {
    totalRelayFee: {
        pct: string;
        total: string;
    };
    relayerCapitalFee: {
        pct: string;
        total: string;
    };
    relayerGasFee: {
        pct: string;
        total: string;
    };
    lpFee: {
        pct: string;
        total: string;
    };
    timestamp: string;
    isAmountTooLow: boolean;
    quoteBlock: string;
    spokePoolAddress: Address;
    exclusiveRelayer: Address;
    exclusivityDeadline: string;
}
/**
 * Encodes a bridging operation for the Across protocol into a user operation
 * @param {BridgingUserOpParams} params - Parameters for the bridge operation
 * @param {bigint} params.bridgingAmount - Amount to bridge
 * @param {Chain} params.fromChain - Source chain information
 * @param {Account} params.account - User's account information
 * @param {Chain} params.toChain - Destination chain information
 * @param {TokenMapping} params.tokenMapping - Token address mapping across chains
 * @returns {Promise<BridgingPluginResult>} Encoded user operation and bridging details
 * @throws {Error} When depositor or recipient address cannot be found
 */
export declare const acrossEncodeBridgingUserOp: (params: BridgingUserOpParams) => Promise<BridgingPluginResult>;
/**
 * Creates an Across bridging plugin instance
 * @returns {BridgingPlugin} Plugin instance implementing the Across bridge protocol
 *
 * @example
 * const acrossPlugin = toAcrossPlugin()
 * const bridgeResult = await acrossPlugin.encodeBridgeUserOp({
 *   bridgingAmount: 1000000n,
 *   fromChain: sourceChain,
 *   toChain: destChain,
 *   account: userAccount,
 *   tokenMapping: tokens
 * })
 */
export declare const toAcrossPlugin: () => BridgingPlugin;
//# sourceMappingURL=toAcrossPlugin.d.ts.map